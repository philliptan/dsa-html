<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Grid Adjacency — DRY Benchmark Harness</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  :root{
    --cell-w: 10px;
    --cell-h: 20px;
    --gap: 0px;
    --base:#eef2f7; --border:#d8dee9; --hover:#ffd54f; --neighbor:#ffecb3;
  }
  body{ font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin:20px; color:#111;}
  .controls{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:10px;}
  .grid{
    display:grid;
    grid-template-columns: repeat(var(--cols), var(--cell-w));
    grid-auto-rows: var(--cell-h);
    gap: var(--gap);
    width: calc(var(--cols) * var(--cell-w));
    border:1px solid var(--border);
    user-select:none;
    contain: content;
    position: relative;
    overflow: hidden;
  }
  .cell{ box-sizing:border-box; background:var(--base); outline:1px solid var(--border); }
  .cell.is-hover{ background: var(--hover); }
  .cell.is-neighbor{ background: var(--neighbor); }

  /* CSS Overlay (Approach 5) */
  .overlay {
    position: absolute;
    width: var(--cw);
    height: var(--ch);
    background: var(--hover);
    pointer-events: none;
    will-change: transform;
  }
  .overlay.cross {
    box-shadow:
      0 calc(-1 * var(--ch)) 0 0 var(--neighbor),
      0 var(--ch)            0 0 var(--neighbor),
      calc(-1 * var(--cw)) 0  0 0 var(--neighbor),
      var(--cw) 0            0 0 var(--neighbor);
  }
  .overlay.cheb {
    box-shadow:
      0 calc(-1 * var(--ch)) 0 0 var(--neighbor),
      0 var(--ch)            0 0 var(--neighbor),
      calc(-1 * var(--cw)) 0  0 0 var(--neighbor),
      var(--cw) 0            0 0 var(--neighbor),
      calc(-1 * var(--cw)) calc(-1 * var(--ch)) 0 0 var(--neighbor),
      var(--cw)            calc(-1 * var(--ch)) 0 0 var(--neighbor),
      calc(-1 * var(--cw)) var(--ch)            0 0 var(--neighbor),
      var(--cw)            var(--ch)            0 0 var(--neighbor);
  }

  .log{ font:12px/1.4 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap;
        background:#f8f9fb; border:1px solid #e5e7eb; padding:10px; border-radius:6px; max-width: 880px;}
  fieldset{ border:1px solid #e5e7eb; border-radius:6px; padding:10px;}
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
  label.inline { display:inline-flex; align-items:center; gap:6px; }
  button{ padding:6px 10px; }
  #stage{ margin-top:10px; }
</style>
</head>
<body>
  <h2>Grid Adjacency — DRY Benchmark Harness</h2>

  <fieldset>
    <legend>Settings</legend>
    <div class="row">
      <label>Approach
        <select id="approach">
          <option value="naive">1) Naive (per-cell listeners)</option>
          <option value="delegation">2) Delegation + Precomputed</option>
          <option value="diff">3) Delegation + Precomputed + Diff</option>
          <option value="bitboard">4) Bitboard (BigInt) + Diff</option>
          <option value="overlay">5) CSS Overlay (single DOM write)</option>
          <option value="canvas2d">6) Canvas 2D (single draw)</option>
        </select>
      </label>
      <label>Rows <input id="rows" type="number" min="1" max="500" value="40" style="width:5em"></label>
      <label>Cols <input id="cols" type="number" min="1" max="500" value="40" style="width:5em"></label>
      <label class="inline"><input type="checkbox" id="diag"> Include diagonals (8-neighbors)</label>
      <label>Passes <input id="passes" type="number" min="1" max="50" value="5" style="width:4em"></label>
      <label>Repeats <input id="repeats" type="number" min="1" max="200" value="25" style="width:4em"></label>
      <button id="run">Run benchmark</button>
      <button id="runAll">Run all</button>
      <button id="clear">Clear highlight</button>
    </div>
  </fieldset>

  <div id="stage"></div>

  <h3>Benchmark log</h3>
  <div id="log" class="log"></div>

<script>
(() => {
  'use strict';

  // ===== Shared Utils (DRY) =====
  const logEl = document.getElementById('log');
  const stage = document.getElementById('stage');
  const $ = (id) => document.getElementById(id);
  const log = (s='') => logEl.textContent += s + '\n';
  const nextFrame = () => new Promise(requestAnimationFrame);
  const median = (arr) => {
    const s = arr.slice().sort((a,b)=>a-b);
    const m = (s.length-1)/2;
    return s.length % 2 ? s[m] : (s[m] + s[m+1]) / 2;
  };
  const toIdx = (r,c,cols) => r * cols + c;
  const toRC  = (idx,cols) => [ (idx/cols)|0, idx%cols ];
  const inBounds = (r,c,rows,cols) => r>=0 && r<rows && c>=0 && c<cols;

  function* serpentineIndices(rows, cols) {
    for (let r=0; r<rows; r++) {
      if ((r & 1) === 0) { for (let c=0; c<cols; c++) yield toIdx(r,c,cols); }
      else { for (let c=cols-1; c>=0; c--) yield toIdx(r,c,cols); }
    }
  }

  function buildGrid(container, rows, cols) {
    const grid = document.createElement('div');
    grid.className = 'grid';
    grid.style.setProperty('--rows', String(rows));
    grid.style.setProperty('--cols', String(cols));

    const cells = new Array(rows*cols);
    const frag = document.createDocumentFragment();
    let idx = 0;
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++, idx++) {
        const el = document.createElement('div');
        el.className = 'cell';
        el.dataset.index = String(idx);
        el.dataset.r = String(r);
        el.dataset.c = String(c);
        el.title = `(${r},${c})`;
        frag.appendChild(el);
        cells[idx] = el;
      }
    }
    grid.appendChild(frag);
    container.appendChild(grid);
    return { grid, cells };
  }

  // ===== DRY Benchmark Harness =====
  async function runBenchmark(factory, cfg) {
    stage.innerHTML = '';
    const {rows, cols, diag, passes, repeats} = cfg;

    const t0 = performance.now();
    const approach = factory({ container: stage, rows, cols, diag });
    const coldStartMs = performance.now() - t0;

    const N = rows * cols;
    log(`--- ${approach.name} ---`);
    log(`Cold start: ${coldStartMs.toFixed(2)} ms`);
    log(`Neighbors mode: ${diag ? '8-neighbors' : '4-neighbors'}`);
    log(`Simulating pointer moves: ${repeats} × ${N} cells\n`);

    const results = [];
    for (let p=0; p<passes; p++) {
      approach.clear();
      const t1 = performance.now();

      let prev = -1;
      for (let r=0; r<repeats; r++) {
        for (const idx of serpentineIndices(rows, cols)) {
          approach.transition(prev, idx);
          prev = idx;
        }
      }
      if (typeof approach.finalize === 'function') {
        approach.finalize(prev);
      } else {
        approach.clear();
      }

      const t2 = performance.now();
      const totalMoves = repeats * N;
      const totalMs = t2 - t1;
      const perHoverMs = totalMs / totalMoves;
      const hoversPerSec = 1000 / perHoverMs;

      results.push({ totalMs, perHoverMs, hoversPerSec });
      log(`Pass ${p+1}/${passes}: total ${totalMs.toFixed(1)} ms | avg ${perHoverMs.toFixed(4)} ms/hover | ${hoversPerSec.toFixed(1)} hovers/s`);
      await nextFrame();
    }

    const perHoverList = results.map(r => r.perHoverMs);
    const totalList    = results.map(r => r.totalMs);
    const hpsList      = results.map(r => r.hoversPerSec);

    const summary = {
      approach: approach.summaryLabel,
      neighbors: diag ? 8 : 4,
      coldStartMs: Number(coldStartMs.toFixed(2)),
      passes, repeats,
      cells: N,
      listeners: approach.listeners,
      perHoverMs_avg: Number((perHoverList.reduce((a,b)=>a+b,0)/perHoverList.length).toFixed(5)),
      perHoverMs_median: Number(median(perHoverList).toFixed(5)),
      hoversPerSec_median: Number(median(hpsList).toFixed(1)),
      totalMs_median: Number(median(totalList).toFixed(1))
    };

    log(`\nSummary: ${JSON.stringify(summary, null, 2)}`);
    window.__BENCH_LAST__ = summary;
    return summary;
  }

  // ===== Approach 1: Naive (per-cell listeners) =====
  function approachNaiveFactory({ container, rows, cols, diag }) {
    const name = 'Approach 1 — Naive (per-cell listeners)';
    const summaryLabel = 'Naive';
    const N = rows * cols;
    const { grid, cells } = buildGrid(container, rows, cols);

    function getNeighbors(r, c) {
      const out = [];
      if (inBounds(r-1,c,rows,cols)) out.push(toIdx(r-1,c,cols));
      if (inBounds(r+1,c,rows,cols)) out.push(toIdx(r+1,c,cols));
      if (inBounds(r,c-1,rows,cols)) out.push(toIdx(r,c-1,cols));
      if (inBounds(r,c+1,rows,cols)) out.push(toIdx(r,c+1,cols));
      if (diag) {
        if (inBounds(r-1,c-1,rows,cols)) out.push(toIdx(r-1,c-1,cols));
        if (inBounds(r-1,c+1,rows,cols)) out.push(toIdx(r-1,c+1,cols));
        if (inBounds(r+1,c-1,rows,cols)) out.push(toIdx(r+1,c-1,cols));
        if (inBounds(r+1,c+1,rows,cols)) out.push(toIdx(r+1,c+1,cols));
      }
      return out;
    }

    let lastIdx = -1;
    function onEnter(e){ const idx = Number(e.currentTarget.dataset.index); enter(idx); lastIdx = idx; }
    function onLeave(e){ const idx = Number(e.currentTarget.dataset.index); leave(idx); lastIdx = -1; }

    for (let i=0; i<N; i++){
      cells[i].addEventListener('mouseenter', onEnter);
      cells[i].addEventListener('mouseleave', onLeave);
    }

    function enter(idx){
      const [r,c] = toRC(idx, cols);
      const neigh = getNeighbors(r,c);
      cells[idx].classList.add('is-hover');
      for (let i=0; i<neigh.length; i++) cells[neigh[i]].classList.add('is-neighbor');
    }
    function leave(idx){
      const [r,c] = toRC(idx, cols);
      const neigh = getNeighbors(r,c);
      cells[idx].classList.remove('is-hover');
      for (let i=0; i<neigh.length; i++) cells[neigh[i]].classList.remove('is-neighbor');
    }

    return {
      name, summaryLabel, listeners: N*2,
      transition(prev, next){
        if (prev !== -1) leave(prev);
        enter(next);
        lastIdx = next;
      },
      clear(){
        if (lastIdx !== -1) leave(lastIdx);
        lastIdx = -1;
      },
      finalize(prev){
        if (prev !== -1) leave(prev);
        lastIdx = -1;
      }
    };
  }

  // ===== Approach 2: Delegation + Precomputed =====
  function approachDelegationFactory({ container, rows, cols, diag }) {
    const name = 'Approach 2 — Delegation + Precomputed';
    const summaryLabel = 'Delegation+Precomputed';
    const N = rows * cols;
    const { grid, cells } = buildGrid(container, rows, cols);

    /** @type {number[][]} */ const neighbors4 = new Array(N);
    /** @type {number[][]} */ const neighbors8 = new Array(N);
    for (let r=0; r<rows; r++){
      for (let c=0; c<cols; c++){
        const idx = toIdx(r,c,cols);
        const n4 = [];
        if (inBounds(r-1,c,rows,cols)) n4.push(toIdx(r-1,c,cols));
        if (inBounds(r+1,c,rows,cols)) n4.push(toIdx(r+1,c,cols));
        if (inBounds(r,c-1,rows,cols)) n4.push(toIdx(r,c-1,cols));
        if (inBounds(r,c+1,rows,cols)) n4.push(toIdx(r,c+1,cols));
        neighbors4[idx] = n4;

        const n8 = n4.slice();
        if (inBounds(r-1,c-1,rows,cols)) n8.push(toIdx(r-1,c-1,cols));
        if (inBounds(r-1,c+1,rows,cols)) n8.push(toIdx(r-1,c+1,cols));
        if (inBounds(r+1,c-1,rows,cols)) n8.push(toIdx(r+1,c-1,cols));
        if (inBounds(r+1,c+1,rows,cols)) n8.push(toIdx(r+1,c+1,cols));
        neighbors8[idx] = n8;
      }
    }

    grid.addEventListener('pointermove', (e) => {
      const cell = e.target && e.target.closest('.cell');
      if (!cell || !grid.contains(cell)) return;
      highlight(Number(cell.dataset.index));
    }, { passive: true });
    grid.addEventListener('pointerleave', () => clear());

    let lastIdx = -1;
    /** @type {number[]} */ let lastSet = [];

    function clear(){
      if (!lastSet.length) { lastIdx = -1; return; }
      for (let i=0; i<lastSet.length; i++){
        cells[lastSet[i]].classList.remove('is-hover','is-neighbor');
      }
      lastSet.length = 0;
      lastIdx = -1;
    }

    function highlight(idx){
      if (idx === lastIdx) return;
      if (lastSet.length){
        for (let i=0; i<lastSet.length; i++){
          cells[lastSet[i]].classList.remove('is-hover','is-neighbor');
        }
      }
      const neigh = (diag ? neighbors8[idx] : neighbors4[idx]);
      cells[idx].classList.add('is-hover');
      for (let i=0; i<neigh.length; i++) cells[neigh[i]].classList.add('is-neighbor');
      lastSet = [idx, ...neigh];
      lastIdx = idx;
    }

    return {
      name, summaryLabel, listeners: 2,
      transition(prev, next){ highlight(next); },
      clear,
      finalize(){ clear(); }
    };
  }

  // ===== Approach 3: Delegation + Precomputed + Diff =====
  function approachDiffFactory({ container, rows, cols, diag }) {
    const name = 'Approach 3 — Delegation + Precomputed + Diff';
    const summaryLabel = 'Delegation+Precomputed+Diff';
    const N = rows * cols;
    const { grid, cells } = buildGrid(container, rows, cols);

    /** @type {number[][]} */ const neighbors4 = new Array(N);
    /** @type {number[][]} */ const neighbors8 = new Array(N);
    for (let r=0; r<rows; r++){
      for (let c=0; c<cols; c++){
        const idx = toIdx(r,c,cols);
        const n4 = [];
        if (inBounds(r-1,c,rows,cols)) n4.push(toIdx(r-1,c,cols));
        if (inBounds(r+1,c,rows,cols)) n4.push(toIdx(r+1,c,cols));
        if (inBounds(r,c-1,rows,cols)) n4.push(toIdx(r,c-1,cols));
        if (inBounds(r,c+1,rows,cols)) n4.push(toIdx(r,c+1,cols));
        neighbors4[idx] = n4;
        const n8 = n4.slice();
        if (inBounds(r-1,c-1,rows,cols)) n8.push(toIdx(r-1,c-1,cols));
        if (inBounds(r-1,c+1,rows,cols)) n8.push(toIdx(r-1,c+1,cols));
        if (inBounds(r+1,c-1,rows,cols)) n8.push(toIdx(r+1,c-1,cols));
        if (inBounds(r+1,c+1,rows,cols)) n8.push(toIdx(r+1,c+1,cols));
        neighbors8[idx] = n8;
      }
    }

    const mark = new Uint8Array(N);

    grid.addEventListener('pointermove', (e) => {
      const cell = e.target && e.target.closest('.cell');
      if (!cell || !grid.contains(cell)) return;
      highlight(Number(cell.dataset.index));
    }, { passive: true });
    grid.addEventListener('pointerleave', () => clear());

    let lastIdx = -1;

    function clear(){
      if (lastIdx === -1) return;
      const prevNeigh = (diag ? neighbors8[lastIdx] : neighbors4[lastIdx]);
      cells[lastIdx].classList.remove('is-hover');
      for (let i=0; i<prevNeigh.length; i++){
        cells[prevNeigh[i]].classList.remove('is-neighbor');
      }
      lastIdx = -1;
    }

    function highlight(idx){
      if (idx === lastIdx) return;

      const prevIdx = lastIdx;
      const prevNeigh = (prevIdx === -1) ? [] : (diag ? neighbors8[prevIdx] : neighbors4[prevIdx]);
      const nextNeigh = (diag ? neighbors8[idx] : neighbors4[idx]);

      for (let i=0; i<prevNeigh.length; i++) mark[prevNeigh[i]] = 1;
      for (let i=0; i<nextNeigh.length; i++){
        const v = nextNeigh[i];
        if (mark[v] === 1) mark[v] = 2; else cells[v].classList.add('is-neighbor');
      }
      for (let i=0; i<prevNeigh.length; i++){
        const v = prevNeigh[i];
        if (mark[v] === 1) cells[v].classList.remove('is-neighbor');
        mark[v] = 0;
      }

      if (prevIdx !== -1) cells[prevIdx].classList.remove('is-hover');
      cells[idx].classList.add('is-hover');

      lastIdx = idx;
    }

    return {
      name, summaryLabel, listeners: 2,
      transition(prev, next){ highlight(next); },
      clear,
      finalize(){ clear(); }
    };
  }

  // ===== Approach 4: Bitboard (BigInt) + Diff =====
  function approachBitboardFactory({ container, rows, cols, diag }) {
    const name = 'Approach 4 — Bitboard (BigInt) + Diff';
    const summaryLabel = 'Bitboard+Diff';
    const N = rows * cols;
    const { grid, cells } = buildGrid(container, rows, cols);

    const BIG0 = 0n;
    const one = 1n;
    const COLS = BigInt(cols);
    const FULL = (one << BigInt(N)) - one;

    let leftEdge = 0n, rightEdge = 0n, topRow = 0n, bottomRow = 0n;
    for (let r = 0; r < rows; r++) {
      leftEdge   |= (one << BigInt(r*cols + 0));
      rightEdge  |= (one << BigInt(r*cols + (cols-1)));
    }
    for (let c = 0; c < cols; c++) {
      topRow     |= (one << BigInt(c));
      bottomRow  |= (one << BigInt((rows-1)*cols + c));
    }
    const notLeft   = FULL ^ leftEdge;
    const notRight  = FULL ^ rightEdge;
    const notTop    = FULL ^ topRow;
    const notBottom = FULL ^ bottomRow;

    const shl = (x, k) => (x << BigInt(k)) & FULL;
    const shr = (x, k) => (x >> BigInt(k));

    function neighborsMask(idx) {
      const m = (one << BigInt(idx));
      let mask = BIG0;
      mask |= shr(m & notTop, COLS);           // up
      mask |= shl(m & notBottom, COLS);        // down
      mask |= shr(m & notLeft, 1);             // left
      mask |= shl(m & notRight, 1);            // right
      if (diag) {
        mask |= shr(m & notTop & notLeft,  COLS + 1n);
        mask |= shr(m & notTop & notRight, COLS - 1n);
        mask |= shl(m & notBottom & notLeft,  COLS - 1n);
        mask |= shl(m & notBottom & notRight, COLS + 1n);
      }
      return mask;
    }

    function forEachSetBit(mask, cb) {
      let base = 0;
      while (mask !== 0n) {
        let x = Number(mask & 0xFFFFFFFFn) >>> 0;
        while (x) {
          const lsb = x & -x;
          const bit = 31 - Math.clz32(lsb);
          cb(base + bit);
          x ^= lsb;
        }
        mask >>= 32n;
        base += 32;
      }
    }

    let lastIdx = -1;
    let lastMask = BIG0;

    function clear(){
      if (lastIdx === -1) return;
      cells[lastIdx].classList.remove('is-hover');
      forEachSetBit(lastMask, (i) => { cells[i].classList.remove('is-neighbor'); });
      lastIdx = -1;
      lastMask = BIG0;
    }

    function highlight(idx) {
      if (idx === lastIdx) return;
      const nextMask = neighborsMask(idx);
      const toRemove = lastMask & ((~nextMask) & FULL);
      const toAdd    = nextMask & ((~lastMask) & FULL);

      forEachSetBit(toRemove, (i) => { cells[i].classList.remove('is-neighbor'); });
      forEachSetBit(toAdd,    (i) => { cells[i].classList.add('is-neighbor'); });

      if (lastIdx !== -1) cells[lastIdx].classList.remove('is-hover');
      cells[idx].classList.add('is-hover');

      lastIdx = idx;
      lastMask = nextMask;
    }

    grid.addEventListener('pointermove', (e) => {
      const cell = e.target && e.target.closest('.cell');
      if (!cell || !grid.contains(cell)) return;
      highlight(Number(cell.dataset.index));
    }, { passive: true });
    grid.addEventListener('pointerleave', () => clear());

    return {
      name, summaryLabel, listeners: 2,
      transition(prev, next){ highlight(next); },
      clear,
      finalize(){ clear(); }
    };
  }

  // ===== NEW — Approach 5: CSS Overlay (single DOM write) =====
  function approachOverlayFactory({ container, rows, cols, diag }) {
    const name = 'Approach 5 — CSS Overlay (single DOM write)';
    const summaryLabel = 'CSSOverlay';
    const { grid, cells } = buildGrid(container, rows, cols);

    const overlay = document.createElement('div');
    overlay.className = 'overlay ' + (diag ? 'cheb' : 'cross');
    overlay.style.display = 'none';
    overlay.style.pointerEvents = 'none';

    const cw = (cells[0]?.offsetWidth || 10);
    const ch = (cells[0]?.offsetHeight || 20);
    overlay.style.setProperty('--cw', cw + 'px');
    overlay.style.setProperty('--ch', ch + 'px');

    grid.appendChild(overlay);

    function moveTo(idx){
      const [r,c] = toRC(idx, cols);
      overlay.style.transform = `translate(${c * cw}px, ${r * ch}px)`;
      overlay.style.display = 'block';
    }
    function hide(){ overlay.style.display = 'none'; }

    grid.addEventListener('pointermove', (e) => {
      const cell = e.target && e.target.closest('.cell');
      if (!cell || !grid.contains(cell)) return;
      moveTo(Number(cell.dataset.index));
    }, { passive: true });
    grid.addEventListener('pointerleave', () => hide());

    return {
      name, summaryLabel, listeners: 2,
      transition(prev, next){ moveTo(next); },
      clear(){ hide(); },
      finalize(){ hide(); }
    };
  }

  // ===== NEW — Approach 6: Canvas 2D (single draw per move) =====
  function approachCanvas2DFactory({ container, rows, cols, diag }) {
    const name = 'Approach 6 — Canvas 2D (single draw)';
    const summaryLabel = 'Canvas2D';
    // We do NOT create 1600 divs. We draw everything on canvas for max throughput.

    // Read CSS vars for colors and cell size
    const root = getComputedStyle(document.documentElement);
    const colorBase = root.getPropertyValue('--base').trim() || '#eef2f7';
    const colorBorder = root.getPropertyValue('--border').trim() || '#d8dee9';
    const colorHover = root.getPropertyValue('--hover').trim() || '#ffd54f';
    const colorNeighbor = root.getPropertyValue('--neighbor').trim() || '#ffecb3';

    // Try to read cell size from CSS vars; fallback to defaults
    const cw = parseFloat(root.getPropertyValue('--cell-w')) || 10;
    const ch = parseFloat(root.getPropertyValue('--cell-h')) || 20;
    const W = cols * cw;
    const H = rows * ch;

    // Wrapper sized like the grid for consistency
    const grid = document.createElement('div');
    grid.className = 'grid';
    grid.style.setProperty('--rows', String(rows));
    grid.style.setProperty('--cols', String(cols));
    grid.style.position = 'relative';
    grid.style.display = 'block'; // we don't populate with cells
    container.appendChild(grid);

    // Canvas + DPR setup
    const dpr = window.devicePixelRatio || 1;
    const canvas = document.createElement('canvas');
    canvas.style.width  = W + 'px';
    canvas.style.height = H + 'px';
    canvas.width  = Math.round(W * dpr);
    canvas.height = Math.round(H * dpr);
    grid.appendChild(canvas);
    const ctx = canvas.getContext('2d', { alpha: false });
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // logical units = CSS px

    // Pre-render static background (grid fill + lines) to an offscreen canvas
    const bg = document.createElement('canvas');
    bg.width = canvas.width; bg.height = canvas.height;
    const bgctx = bg.getContext('2d', { alpha: false });
    bgctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // Base fill
    bgctx.fillStyle = colorBase;
    bgctx.fillRect(0, 0, W, H);

    // Grid lines
    bgctx.strokeStyle = colorBorder;
    bgctx.lineWidth = 1;
    // crisp lines at 0.5 offset in CSS pixels
    bgctx.beginPath();
    for (let r = 0; r <= rows; r++) {
      const y = Math.round(r * ch) + 0.5;
      bgctx.moveTo(0, y);
      bgctx.lineTo(W, y);
    }
    for (let c = 0; c <= cols; c++) {
      const x = Math.round(c * cw) + 0.5;
      bgctx.moveTo(x, 0);
      bgctx.lineTo(x, H);
    }
    bgctx.stroke();

    // Neighbor precompute (like Approach 2)
    const N = rows * cols;
    /** @type {number[][]} */ const neighbors4 = new Array(N);
    /** @type {number[][]} */ const neighbors8 = new Array(N);
    const toIndex = (r,c) => r * cols + c;
    const inB = (r,c) => r>=0 && r<rows && c>=0 && c<cols;
    for (let r=0; r<rows; r++) {
      for (let c=0; c<cols; c++) {
        const idx = toIndex(r,c);
        const n4 = [];
        if (inB(r-1,c)) n4.push(toIndex(r-1,c));
        if (inB(r+1,c)) n4.push(toIndex(r+1,c));
        if (inB(r,c-1)) n4.push(toIndex(r,c-1));
        if (inB(r,c+1)) n4.push(toIndex(r,c+1));
        neighbors4[idx] = n4;

        const n8 = n4.slice();
        if (inB(r-1,c-1)) n8.push(toIndex(r-1,c-1));
        if (inB(r-1,c+1)) n8.push(toIndex(r-1,c+1));
        if (inB(r+1,c-1)) n8.push(toIndex(r+1,c-1));
        if (inB(r+1,c+1)) n8.push(toIndex(r+1,c+1));
        neighbors8[idx] = n8;
      }
    }

    function drawHighlight(idx) {
      // blit BG
      ctx.drawImage(bg, 0, 0, bg.width / dpr, bg.height / dpr);
      // neighbors
      const neigh = (diag ? neighbors8[idx] : neighbors4[idx]);
      ctx.fillStyle = colorNeighbor;
      for (let i=0; i<neigh.length; i++) {
        const n = neigh[i];
        const nr = (n / cols) | 0;
        const nc = n % cols;
        ctx.fillRect(nc * cw, nr * ch, cw, ch);
      }
      // center
      const r = (idx / cols) | 0, c = idx % cols;
      ctx.fillStyle = colorHover;
      ctx.fillRect(c * cw, r * ch, cw, ch);
    }

    function clientToIndex(e) {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const c = Math.floor(x / cw);
      const r = Math.floor(y / ch);
      if (!inB(r,c)) return -1;
      return r * cols + c;
    }

    // Interactive events
    let lastIdx = -1;
    canvas.addEventListener('pointermove', (e) => {
      const idx = clientToIndex(e);
      if (idx === -1 || idx === lastIdx) return;
      drawHighlight(idx);
      lastIdx = idx;
    }, { passive: true });

    canvas.addEventListener('pointerleave', () => {
      // restore background only
      ctx.drawImage(bg, 0, 0, bg.width / dpr, bg.height / dpr);
      lastIdx = -1;
    });

    // Initial paint
    ctx.drawImage(bg, 0, 0, bg.width / dpr, bg.height / dpr);

    return {
      name, summaryLabel, listeners: 2,
      transition(prev, next){ drawHighlight(next); },
      clear(){ ctx.drawImage(bg, 0, 0, bg.width / dpr, bg.height / dpr); lastIdx = -1; },
      finalize(){ ctx.drawImage(bg, 0, 0, bg.width / dpr, bg.height / dpr); lastIdx = -1; }
    };
  }

  // ===== Wire up UI =====
  const approachSel = $('approach');
  const rowsInp = $('rows');
  const colsInp = $('cols');
  const diagInp = $('diag');
  const passesInp = $('passes');
  const repeatsInp = $('repeats');

  const factories = {
    naive: approachNaiveFactory,
    delegation: approachDelegationFactory,
    diff: approachDiffFactory,
    bitboard: approachBitboardFactory,
    overlay: approachOverlayFactory,
    canvas2d: approachCanvas2DFactory,
  };

  $('run').addEventListener('click', async () => {
    logEl.textContent = '';
    const cfg = {
      rows: Number(rowsInp.value),
      cols: Number(colsInp.value),
      diag: diagInp.checked,
      passes: Number(passesInp.value),
      repeats: Number(repeatsInp.value)
    };
    await runBenchmark(factories[approachSel.value], cfg);
  });

  $('runAll').addEventListener('click', async () => {
    logEl.textContent = '';
    const cfg = {
      rows: Number(rowsInp.value),
      cols: Number(colsInp.value),
      diag: diagInp.checked,
      passes: Number(passesInp.value),
      repeats: Number(repeatsInp.value)
    };
    for (const key of ['naive','delegation','diff','bitboard','overlay','canvas2d']) {
      await runBenchmark(factories[key], cfg);
      log('\n');
    }
  });

  $('clear').addEventListener('click', () => { stage.innerHTML = ''; });

})();
</script>
</body>
</html>
